# 手写代码

## Object.create

用已有对象作为原型，创建一个新对象。

```javascript
/**
 *
 * @param {object | null} obj
 */
function create(obj) {
  p = Object(obj)
  const res = new Object({})
  Object.setPrototypeOf(res, p)
  return res
}
```

## instanceof

```javascript
/**
 * instanceof
 * @param {*} a
 * @param {*} b
 */
function instance(a, b) {
  if(typeof a !== Object) return false;

  if(a === null) {
    return false
  }

  const proto = Object.getPrototypeOf(a)
  if(b.prototype && b.prototype === proto) {
    return true
  }

  return instance(proto, b)
}

```

## Promise.race

```javascript
/**
 * 执行最快，并返回它的结果， arr 为空是，返回一个永远pending的promise
 * @param {Promise} arr
 * @returns
 */
function race(arr) {
  return new Promise((resolve, reject) => {
    for (let i = 0; i < array.length; i++) {
      arr[i].then(resolve, reject)
    }
  })
}
```

## 防抖函数

```javascript
/**
 * 防抖
 * 函数防抖是指在事件被触发 n 秒后再执行回调，如果在这 n 秒内事件又被触发，则重新计时
 *
 * 1. 这可以使用在一些点击请求的事件上，避免因为用户的多次点击向后端发送多次请求。
 * 2. 页面resize事件
 *
 * @param {*} cb
 * @param {*} time
 * @returns
 */
function debounce(cb, time = 0) {
  let timer = null

  return function _debounce() {
    let content = this
    let args = arguments

    if(timer) {
      clearTimeout(timer)
      timer = null
    }
    timer = setTimeout(() => {
      fn.apply(content, args);
    }, time)
  }
}
```

## 节流函数

```javascript
/**
 *
 * 节流函数
 * 固定时间内，执行一次，期间其他方法忽略
 *
 * 节流可以使用在 scroll 函数的事件监听上，通过事件节流来降低事件调用的频率。
 * 例如输入框的搜索功能
 *
 * @param {*} fn
 * @param {*} timeout
 * @returns
 */
function throttle(fn, duration = 0) {
  let preT

  return function () {
    const context = this
    const args = arguments
    const currentT = Date.now()

    if (!preT || currentT - preT >= duration) {
      preT = currentT
      fn.apply(context, args)
    }
  }
}
```

## 类型判断


```javascript
/**
 *
function getType(any) {

}
```